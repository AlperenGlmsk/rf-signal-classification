% Generated by MATLAB(R) 24.2 (R2024b) and LTE Toolbox 24.2 (R2024b).
% Generated on: 08-Dec-2024 13:46:56

%% Generating Downlink RMC waveform
% Downlink RMC configuration
cfg = struct('RC', 'R.0', ...
    'DuplexMode', 'FDD', ...
    'NCellID', 0, ...
    'TotSubframes', 10, ...
    'NumCodewords', 1, ...
    'Windowing', 0, ...
    'AntennaPort', 1);

cfg.OCNGPDSCHEnable = 'Off';
cfg.OCNGPDCCHEnable = 'Off';
cfg.PDSCH.TxScheme = 'Port0';
cfg.PDSCH.RNTI = 1;
cfg.PDSCH.Rho = 0;
cfg.PDSCH.RVSeq = [0 1 2 3];
cfg.PDSCH.NHARQProcesses = 8;
cfg.PDSCH.PMISet = 1;
cfg = lteRMCDL(cfg);

% input bit source:
in = [1; 0; 0; 1];


% Generation
[lte_waveform, grid, cfg] = lteRMCDLTool(cfg, in);

Fs = cfg.SamplingRate; 								 % Specify the sample rate of the waveform in Hz

%% Impairments
% Memoryless cubic nonlinearity
nonlin = comm.MemorylessNonlinearity(	'LinearGain', 		0, ...
    'IIP3', 					30, ...
    'AMPMConversion', 10);
lte_waveform = nonlin(complex(lte_waveform));

% IQ imbalance
lte_waveform = iqimbal(lte_waveform, 8, (180/pi)*pi/5);

% Frequency offset
freqOff = comm.PhaseFrequencyOffset('FrequencyOffset', 10, ...
    'SampleRate', 		Fs);
lte_waveform = freqOff(lte_waveform);


% Phase offset
lte_waveform = lte_waveform * exp(1i*pi/8);

% DC offset
lte_waveform = lte_waveform + 0.1+0.2i;

% AWGN
lte_waveform = awgn(lte_waveform, 20, 'measured');

%% Visualize
% Spectrum Analyzer
% spectrum = spectrumAnalyzer('SampleRate', Fs);
% spectrum(waveform);
% release(spectrum);

%% Table
signal = lte_waveform;

% Parça boyutu
chunk_size = (length(signal)/100);

% Parça sayısı
num_chunks = floor(length(signal) / chunk_size);

% Sonuçları saklamak için tablolar
real_stats = zeros(num_chunks, 8); % Gerçek kısım istatistikleri
imag_stats = zeros(num_chunks, 8); % Sanal kısım istatistikleri
chunk_indices = (1:num_chunks)'; % Her parçanın indisi

% Parça bazlı hesaplamalar
for i = 1:num_chunks
    % Şu anki parçanın başlangıç ve bitiş indeksleri
    start_idx = (i - 1) * chunk_size + 1;
    end_idx = start_idx + chunk_size - 1;

    % Şu anki parça
    chunk = signal(start_idx:end_idx);

    % Gerçek ve sanal kısımlar
    real_part = real(chunk);
    imag_part = imag(chunk);

    % Gerçek kısım istatistikleri
    real_stats(i, 1) = min(real_part);
    real_stats(i, 2) = max(real_part);
    real_stats(i, 3) = mean(real_part);
    real_stats(i, 4) = median(real_part);
    real_stats(i, 5) = max(real_part) - min(real_part); % Peak-to-peak
    real_stats(i, 6) = rms(real_part); % RMS
    real_stats(i, 7) = std(real_part);
    real_stats(i, 8) = var(real_part);
    
    
    % Sanal kısım istatistikleri
    imag_stats(i, 1) = min(imag_part);
    imag_stats(i, 2) = max(imag_part);
    imag_stats(i, 3) = mean(imag_part);
    imag_stats(i, 4) = median(imag_part);
    imag_stats(i, 5) = max(imag_part) - min(imag_part); % Peak-to-peak
    imag_stats(i, 6) = rms(imag_part); % RMS
    imag_stats(i, 7) = std(imag_part);
    imag_stats(i, 8) = var(imag_part);
end

category = repmat({'lte'}, num_chunks, 1);

% Sonuçları tabloya koyma
real_stats_table_lte = array2table(real_stats, 'VariableNames', ...
    {'Min', 'Max', 'Mean', 'Median', 'PeakToPeak', 'RMS', 'Std', 'Var'});
real_stats_table_lte.Type = category; % Kategori sütununu ekle

imag_stats_table_lte = array2table(imag_stats, 'VariableNames', ...
    {'Min', 'Max', 'Mean', 'Median', 'PeakToPeak', 'RMS', 'Std', 'Var'});

imag_stats_table_lte.Type = category; % Kategori sütununu ekle

